Embedded System

**CPU(central processing unit)->

*motherboard->

-RAM connected to motherboard through RAM Module in vertical way||||
-secondary storage devious(Auxiliary memory) like hard disc drive connected through cable this is an I/O device
-Power supply SMPS(switch mode power supply) supply direct current to all devices
-we store data permanently on secondary storage to run the applications we store it temporarily on RAM
-Microprocessor is under the heat sink(fan) for cooling purpose


1)Microprocessor(8085)(uP)->

	i)Resisters-> store data(from memory) and instructions(from i/o devices) temporarily
-made of flip-flop and latches 
	ii)Timing and control unit-> 
*Timing unit-> take care about order(sequence) of instructions to be perform
*control unit-> activate the required component
	iii)Arithmetic & logic unit->
	iv)Interface-> interface all component to uP

2)Microcontroller(8051)(uC)->

-used in oven, washing machine, coffee machine etc.
-have uP in it
-memory interface needed to store instructions for operation
-Timer interface used for delay
-interfacing circuit (other interfaces)



*Evolution of computers
-Mechanical era(1623-1940)->
	-first calculator clock built in 1623
	-in 1642 Pascaline can perform addition & sub
	-in 1671 step Reckoner can perform multiplication and division also
	-Difference engine and analytical engine(1st gen of general purpose computer)
	-logic gates are mechanical not electrical
	
-first generation(1940-1950)->
	-use vacuum tube which work as a switch
	-vacuum tube are used in 6 ways as rectifier, amplifier, generator etc.
	-gates are build using this tube

-2nd generation(1950-60)->
	-transistors replace vacuum tube
	-Advantages->	smaller size
			energy efficient
			higher reliability
			greater durability
			less power consumption
			solid state in nature
			faster response time
			higher frequency
			cost effective
	-gates are build using this transistors(we studied about this in BCE)

-3rd generation(1960-70)->
	-use ICs(Integrator Chip)
	-7408 AND
	-7432 OR
	-7404 NOT
	-ARPAENT with TCP/IP protocol 

-4th generation(1970-present)->
	-(Intel's 4004)1st microprocessor used for calculators


*Integration Techniques->
-1960:Small scale integration(SSI)-> Transistors/chip<=10 
ex. AND, OR, etc.
-1970:Medium scale integration(MSI)-> Transistors/chip<=500
ex. 74181 ALU etc.
-1970:Large scale integration(LSI)-> Transistors/chip<=10K
ex. intel's C4004(C indicate ceramic case) etc.	
    intel's P4004(P indicate plastic case) etc.
-1980:Very Large scale integration(VLSI)-> Transistors/chip>=100K
ex. intel's 80286(134000 transistors) up used in IBMs personal computer AT
-1980:Ultra Large scale integration(ULSI)-> Transistors/chip>=1M
ex. intel's Pentium(3.1M transistors) up
    intel's core i9 gen(1.7B transistors) up


*Evaluation of uP->
-intel co founders are Gordon Earle Moore & Robert Noyce
-magnetic core memory is primary core of RAM used in IBMs  360
-invention of uP is accidental
	*BUSICUM(calculator manufacturer) approach intel with a calculator which need 12 chips this led to an idea that the logical unit can be replace by several chips

**note->1 byte = 8 bit

	*1971:intel 4000 family->4001:256 byte ROM
				 4002:40 byte RAM(80 address locations to store 4 bit each due to 4 bit uP)
				4003:10 bit i/o shift resister
				4004:4 bit uP(handles 4 bit of data)
				......
				......

	*1972:intel 8008 8 bit uP->
	*1974:intel 8080 8 bit->use 8224 clock generator
				       8228 system controller
	*1977:intel 8085 8 bit->
	*1978:intel 8086 16 bit->80186,80286
	*1985:intel 80386 32 bit->80486
	*1993:intel Pentium 1 32 bit->Pentium 2,Pentium 3&4
	*2001 intel Itanium 64 bit->
	*2006:intel Core 2 Duo(2 uP 64 bit it)
	*2007 intel Core 2 Quad(4 uP)->Core i5 & Core i7
	*2010:intel Core i3
	*2017:intel Core i7 & i9(8 uP)


**note-> 0V to 0.8V = 0 in binary
	 2V to 5V = 1 in binary
	
	0/1: 1bit 
	4 bit: 1 nibble
	8 bit: 1 byte
	1024 bytes: 1KB
	1024 KB: 1MB
	1024 MB: 1GB
	1024 GB: 1TB.......


**CONVERSION
*binary to decimal->(0110)=(6)=(0*2^3 + 1*2^2 + 1*2^1 + 0*2^0)
*hex to decimal-> (0110)=(272)=(0*16^3 + 1*16^2 + 1*16^1 + 0*16^0)
		  (ABC)=()=(10*16^2 + 11*16^1 + 12*16^0)
*decimal to binary->(25)=(25/2,ans/2,ans/2.....) and revere the order of remembers obtain each time
*decimal to hex->(25)=(25/16,ans/16,ans/16.....) and revere the order of remembers obtain each time

OR CONVERT DECIMAL TO BINARY AND THEN BINARY TO HEX


**ADDITION
*Addition in binary->(789)+(556)=(1 345)
*Addition in hex->(789)+(556)=(CDF)
		   
use formula for addition with carry in hex 
(16+x)= addition in decimal(where x is Ans)
(BAF)+(DAF)=
		F+F=((16+x)=30)=14=			E
		A+A=((16+x)=20+1(max value of carry))=	5
		B+D=((16+x)=24+1)=			9

		Ans = 195E

**THIS HAVE A SHORTCUT SEE IN VIDEO OF *Neso Academy


**SUBTRACTION
*sub in binary->(1001)-(0010)=(0111)
		   9  -  2   =  7

**note-> we can perform subtraction using addition circuit only no need of separate circuit for sub 
			A-B=A+(-B)=A+(B compliment)
there are two ways of doing this 

*1s compliment(demi nix)->
subtract each bit of 2nd no. from 1 and then add them
(1101)-(1011)=(1101)+(0100)=(1 0001)=(0001)+1(end around carry)=(0010)
*2s compliment(radix)->
1s compliment + 1 and then add (discard the carry )
**shortcut->return all bits as it is till first 1 and then toggle the bits onward

*sub in hex->(FAB)-(AEF)=(4BC)we take borrow 1 i.e. 16 in hex

			B-F = 1B-F = (16+11)-15 = 12=C

**note-> we can perform subtraction using addition circuit only no need of separate circuit for sub 
			A-B=A+(-B)=A+(B compliment)
there are two ways of doing this 

*15s compliment(demi nix)-> 
subtract each bit of 2nd no. from F and then add them
(C49)-(28B)=(C49)+(D74)=(1 9BD)=(9BD)+1(end around carry)=(9BE)
*16s compliment(radix)->
15s compliment + 1 and then add (discard the carry )


*for a uP of 4 bit 
-unsigned representation-> 0 to (2^(4)-1) = 0 to 15 i.e. it can perform operation on 4 positive bits and the result is also in 4 bits
-place values are (8 4 2 1) for B
-(1011)= (8+2+1)= 11 

*for a uP of 4 bit 
-signed representation-> (-2^(4-1)) to (2^(4-1)-1)0 to 7 and -8 to -1 = -8 to 7 i.e. it can perform operation on +ve and -ve 4 bits and the result is also in 4 bits
-place values are (-8 4 2 1) for -B i.e. B compliment
-(1011)= (-8+2+1)= -5 

*for 8 bit
-unsigned->0 to (2^(8)-1) 
-signed->(-2^(8-1)) to (2^(8-1)-1)  



										8085
*40 pin DPI(Dual inline Package) IC->20 pins on each side

*pins 1,2-> X1,X2
-x1 and x2 are connected to a crystal in between
-voltage is applied to x1
-crystal start to vibrate and produce electric signal as freq
-this freq use as clock to 8085
*pin 3,36->RESET OUT and IN

*pin 3-> RESET OUT
-reset the peripherals generated by 8085

*pin 36->RESET IN
-set the program Counter to 0 and clear the buses

*pins 4,5->SOD and SID
-serial output data and serial input data

*pins 6-11-> interrupt pins
6.TRAP->
-non-maskable interrupt->current program is stop and interrupt is run first
-generated by external devices
vector address->0024H
-vector address->instructions to run after a interrupt occur are stored at this address
-use for critical situation like power failure

7-9.RST 7.5,6.5,5.5->
-maskable interrupt->current program is not stop
-generated by software instructions
-RST7.5 > RST 6.5 > RST5.5
-RST->restart
-7.5->vector address=7.5*8=60=003CH
-6.5->vector address=6.5*8=52=0034H
-5.5->vector address=5.5*8=44=002CH
-in main memory->
			003C-JUMP INSTRUCTION
			003D-(16 bit 
			003E address)
			003F-return(RET)
-ex->
1)main code start to execute
2)as RST7.5 appear processor goes to location 003C
3)then JUMP to  the location where 16 bit address is present this address  is the address of the location where the code(instructions) for interrupt is present
4)return goes back to the main code

10.INTR(Interrupt Request)->
-maskable 
-generated by external devices like keyboard
-lowest priority

11.INTA->
-this is active low
-Interrupt Acknowledgement
-in order to service maskable interrupt 8085 have to generate this first

*pins 12-19->Data bus
-AD0(LSB) to AD7(MSB) are bidirectional
-use for receiving the program code from memory
-receiving or sending out a data byte from or to an output port or to memory

*pins 31,32->WR and RD
-write and read are active low
-	WR	RD	FUNCTION
	0	1	output pins	 
	1	0	input pins
	1	1	internal processing is going on
	0	0	uP is not acting normally

*pins 20,40->Vcc and Vss
-Vcc->5V dc power supply
-Vss->ground

*pins 28-21(A15 to A8) and 19-12(AD7 to AD0)->Address bus
-n bits can address 2^n locations
-there are 16 bit from AD0 (A0) to A15 in 8085
-16 bit can address 2^16 locations=65536=64K
-A15  to A8->higher order byte
-A7 to A0->Lower order byte

*pin 30->ALE
-Address Latch Enable
-If ALE=1 then AD7 to  AD0 are acts as address bus i.e. as A7 to A0
-If ALE=0 then AD7 to  AD0 are acts as data bus i.e. as D7 to D0

*pin 34->IO/M(active low)
-	IO/M	WR	RD	FUNCTION
	0	0	1	uP writes to Memory
	0	1	0	uP reads from Memory
	1	0	1	uP writes to Output port
	1	1	0	uP reads to Input port

*pins 29,33->S0 and S1
-status signals
-indicates different phases of instructions cycle
-	IO/M	S1	S0	machine cycle
	0	1	1	Opcode Fetch(OF)
	0	1	0	Memory Read(MR)
	0	0	1	Memory write(MW)
	1	1	0	I/O read(IOR)
	1	0	1	I/O write(IOW)
	1	1	1	Interrupt Acknowledgement(INA)

*pine 35->Ready
-Indicate whether an I/O device(periphery) is ready to send/receive- data
-ready=1 device is ready
-ready=0 uP is waiting for device to be ready

*pin 37->CLK(Out)
-for synchronization with various peripherals

*pins 38,39->HALD and Hold
-Direct Memory Access(DMA) signals
-Hold->External device requests for bus access
-HALD->acknowledged the hold request after this the device have access to buses not 8085 uP


**structure of MPU(micro processor unit)->

*Interface section->
1)Address bus
2)Data bus
3)control bus->	i) Memory and I/O control lines=RD,WR,IO/M, Ready, ALE, So and S1
		ii)CPU and Bus control lines=RESET IN and RESET out, Interrupt lines, Hold and HLDA
		iii)Utility control line= Vcc,Vss,X1 and X2,CLk(Out)

**note->bus have direction

*Resister section->
-set of flip-flop for temporary storage of info like data, program(instructions) or address
1)Resisters accessible to programmers->
	i)General Purpose Resisters->B,C,D,E,H,L(they can be combine together)
	ii)Special Purpose Resisters->	1)8 bit= Accumulator, Index Resister, Status/flag Resister
					2)16 bit= Program Counter, Stack Pointer

2)Resisters Inaccessible to programmers->
	i)Memory Address Resister, Temporary resister

-Importance of resister->
ex-> Y=A*B+C*D+E*f
1)solving this problem by using 2 resisters
-->
1.R1<--A
2.R1<--R1*B
3.R2<--C
4.R2<--R2*D
5.R1<--R2+R2
6.R2<--E
7.R2<--R2*F
8.R1<--R+R2
9.Y<--R1

2)solving this problem by using only 1 resisters
1.R<--A
2.R<--R*B
3.mem<--R
4.R<--C
5.R<--R*D
6.R<--R + mem
7.mem<--R
8.R<--E
9.R<--R*F
10.R<--R + mem
11.Y<--R

*Advantages of using 2 resisters
1)less instructions
2)less memory
3)faster execution
4)easy to write

*General Purpose Resisters(GPRs)&Accumulator->
-A,B,C,D,E,H,L all are of 8 bit 
-the general purpose resister are use as storage spaces
-if we want to perform an operation on info stored in GPRs we need Accumulator
ex->let B=06
	D=02
if we want to add data in B with D and store it back in B then we need to use A otherwise we cant do it
step to follow to do so are as follow->
	1)move the content of reg b to reg A
	2)add A and D
	3)move the result from reg A to reg B

1)Accumulator->
 R<--B
 R<--R*B
here R is acting as Accumulator as it is storing one of the operand and then result is stored in R itself

-a resister pair can store 16 bit data or address
B	C
D	E
H	L

ex->consider the data 00 3C is stored in pair B C
-the instruction (LDAX B) means
-LD(load)A(accumulator)X(resister pair)B(resister B)
-this will load the data at address 00 3C in A

-to store the 16 bit data the H L resister pair work as accumulator
ex->let pair H L store data 12 34 and B C store 56 78 in it
-the instruction (DAD B) means dabble add means addition of 1234 and 5678 is going to be done
-and the result is store in H L accumulator

-if we want to store the data at memory location 00 3C in resister C we need to use H L pair as follow
1)store the location 003C in H L(00(higher bit) in H and 3C(lower bit) in L respectively)
2)MOV C,M(move the data at memory location stored in H L in C)

*Indexing in 8085->
-there is no dedicated index resister in 8085
-still we can do indexing in 8085 using H L
ex->
if we want to move data from locations 003C,003D,003E,003F to resisters A,B,C,D 
first store the location 003C in H L then
1)MOV A,M
2)INX H(means increment H by one location)
3)MOV B,M
4)INX H
5)MOV C,M
6)INX H
7)MOV D,M


*Flags resisters->
*need of flag resisters->
-consider we are performing the addition of two 8 bit binary numbers or 2 digits hex numbers as follows
-				F3+45 = 138
-it is not a 8 bit no. and A can only store up to 8 bit
-in this case flag resister come to help
A	F
B	C
D	E
H	L
-it set the carry flag
-it also help in arithmetic, logical operation, conditional branching

*component of flag resister->
-flag resister is of 8 bit
-	7	6	5	4	3	2	1	0
	S	Z	*	AC	*	P	*	CY
1)Cy(carry)-> it set when a carry has generated from the operation of most significant hexadecimal digit
2)P(parity)-> response to no of 1s in A are even or odd
-if even set to 1 if odd reset to 0
3)AC(auxiliary carry)-> it set when a carry has generated from the operation of least significant hexadecimal digits
4)Z(Zero)-> set if A contain all 0s in it
5)S(Sign)-> in signed representation if MSB of the Accumulator is 1 then it set to 1
-sign flag is ignored in unsigned representation
6)*(don't care)

**note->A and F together called Processor Status Word

*memory of 8085 uP->
-memory of 8085 can have 2^16 = 66636 location from 0000 to FFFF which are addressable through address lines A0 to A15

*Stack Pointer Resister(SP)->
-Is a Special purpose Resister
-it is 16 bit because it contain memory addresses
-the job of SP is to point the top of the stack or point the smallest location with useful information
-i.e. if SP point at 8000 location then processor think all location from 8000 to FFFF have useful information(full) an location 8000 to 0000 don't have useful information(empty)
				0000
				..
				..	
				7FFF	empty locations
					---------------
	smallest location-->	8000	full locations
				8001
				..
				..
				FFFF
-they are use during function call

*Program Counter Resister(PC)->
-to understand PC lets take an ex->
	-Program for 2s compliment: let we have to take 2s compliment of 8 bit data at location F840H using A and store it at location F850H to do so we write following instructions
1)LDA F840H->load A with data at this location
2)CMA->compliment data in A (for 1s compliment)
3)INR A->increment data by 1 (for 2s compliment)
4)STA F850H->store data A in A at location
5)HLD->hald to indicate end of program

-let to load this program in memory of 8085 at location F820 onward
-scenes we have 8 bit data bus each location in memory is of 8 bit therefor the instruction of different sizes are load as follow
				LAD	F820
				40	F821
				F8	..
				CMA	..
				INR A	..
				STA	..
				50	..
				F8	F827
				HTL	F828

-here PC are used PC have the location F820 in it first uP get the info at F820 and execute it
- this location is incremented by 1 each time and instruction are executed one by one
-i.e. its function is to provide the address to uP where next part of instruction is to be found

**note->Programmers view of 8085
			A--	F--
			B--	C--
			D--	E--
			H--	L--
			SP----------
			PC----------

*Organization of 8085 & Memory->
-we have address Pins A0 to A15 
-out of which A15 to A8 are unidirectional and A7 to A0 are bidirectional
-memory need an address decoder which help the memory to get the write address from two different address lines
-to load address on address bus uP use Memory Address Resister(MAR)
-let uP need to communicate with memory location F820
-MAR contain address F820 in it

**note-> one difference in uP & memory is ->we use same lower order address bus as data bus for uP but for memory we have different set of address line and data lines

________________	F8(HB)	  __________________________________
|	    A15	|--------------->|	 |	|______	|	    |
|  MAR	    A8	|--------------->|	 |	|______	|	    |
| |F820|    ALE	|-	20(LB)	 |	 |	|______	|	    |	
|	    AD7	|<-------------->|Decoder|	|_______|F820	    |
|   A       AD0	|<-------------->|	 |	|_______|	    |	
|_______________| ^ ^----^	 |_______|______|_______|___________| 
		  | |	 |____________________>D7| |---|D0	
       Buffer --> \ \_____________________________>|   |<---- separate	
		  |___________________________________>|    data line of 
						               memory

-as the below(different) set of data line come from memory are assessable by only the memory if data is send by uP on Ad7 to AD0 it do not enter in data lines of memory
-for this purpose we use a trisect buffer to generate high impedance so that data send by up do not enter in superset data line of memory

-additionally we also have WR, RD and IO/M pins in uP this are called as control signals
-memory also have its WR and RD pins this are called memory signals
-for this we need 2 'OR gate'.one input to this gats is IO/M and other inputs are WR and RD respectively
-output of 1st OR gate is connected to WR of memory and output of 2sd OR gate is to RD of memory

		     WR	---------------  OR gate
		   IO/M	_______________
				|
				|______
					 OR gate
		     RD	---------------

*Reading from the memory->
-when ALE = 1 address of memory location is send to memory through address buses and data at that location is selected
-then ALE = 0 there for the AD7 to AD0 act as data bus
-IO/M	WR	RD ->to read from memory called MEMR(active low)
  0	1	0
-by this input we gat RD=0 and WR=1 at o/p of OR gate
-but at memory it have bubbles at pins WR and RD so we have to toggle the o/p
-we get WR=0 and RD=1 and memory notified that uP is in interested in reading 
-than data send through data channels of memory to  lower order address and data bus to A of the uP. the time required for this is called Memory Access time

*Writing in memory->
-when ALE = 1 address of memory location is send to memory through address buses and data at that location is selected
-IO/M	WR	RD ->to read from memory called MEMW(active low)
  0	0	1
-then ALE = 0 there for the AD7 to AD0 act as data bus
-in this process lower order address is provided by latch when AD& to AD) are acting as data bus
-by this input we gat RD=1 and WR=0 at o/p of OR gate
-but at memory it have bubbles at pins WR and RD so we have to toggle the o/p
-we get WR=1 and RD=0 and memory notified that uP is in interested in writing 
-then data in A is transfer through data bus to data channel of memory and then to location in memory


*Interfacing devices in 8085->
1)Latch->
-we need to hold the address of location till the process is going on but if we use the lower order address buses for data transfer then we cant hold the address here Latch helps us in it
-it store a single bit of data and keep it until it is updated
-latch is used in8085 to hold the lower order address till read or write operation is completed for this the latch used is 74LS373 which has 8 inbuilt latches in it

2)Tri-state buffer->
-due to this the lower order address doesn't flow in data channel of memory
-it work as valve
-it is utilized for isolation when multiple devices are connected to a shared bus i.e. if many devices are connected to data lines then when 1 device is communicating its Enable is 0 and other set off by E=1
-it has 3 states: 	1)Logic 0
			2)Logic 1	
			3)high impedance/Tri-state (Z)

		   5V	_________________
			|	1	|
	   2V	-------	|---------------|		
			|indefinite Leve|
	   0.8V	-------	|---------------|
			|		|
		   0V	|	0	|
			

-one input to this buffer is Enable which is active low and control the switch inside buffer
-if we give E=0 then the switch will be on scene it is active low and data is transfer through it as it is but if E=1 switch is off and data is not being send
-the high impedance state is not 1 and also not 0 
Ex.1) 74LS5244->unidirectional buffer. used in applications like data transfer between keyboard to CPU
   2)74LS5245->bidirectional buffer. communication between CPU and memory

3)Encoder->
-Encoder is a device used to convert information from one form into another suitable for processing by the uP
-ex. when we press any key on the Keyboard is translated to digital formate by Encoder as follow->
1)Keyboard i/p as electrical signal
2)functioning of Encoder(converting into digital data)
3)Interface with uP through i/p port's
4)processing by uP
5)response by uP

-Encoder is a logic device that convert all of the i/p signal into a coded o/p signal.
-it can be used to reduce the no. of lines in a circuit as follow
-i/p of Encoder are toggle therefor for a 4*2 Encoder

	I4	I3	I2	I1  |	O1	O0		
	1	1	1	1   |	*	*
	1	1	1	0   |	0	0
	1	1	0	1   |	0	1
	1	0	1	1   |	1	0
	0	1	1	1   |	1	1

-the o/p are also toggle therefor   

	I4	I3	I2	I1  |	O1	O0		
	1	1	1	1   |	*	*
	1	1	1	0   |	1	1
	1	1	0	1   |	1	0
	1	0	1	1   |	0	1
	0	1	1	1   |	0	0

-the 74LS148 Encoder is 8*3 generally used Encoder

4)Decoder->
-increase no. of connections
-used to select and activate specific peripheral devices or memory location based on the address signals provided by the uP
-it can be used to decoding of memory and I/O devices
-if we have a decoder of 2 i/p and 4 active low o/p
		
	A1	A0   |  Y0	Y1	Y2	Y3  		
	0	0    |	0	1	1	1  <----Y0 is selected 
	0	1    |	1	0	1	1   
	1	0    |	1	1	0	1   
	1	1    |	1	1	1	0    

-in 8085 we use 74LS138

**note-> 
  1) 2^n=m where n is address lines and m is no. of memory locations
  2)bits/location = no of data lines
  3)capacity of memory = memory locations * size of the memory chip
ex-> 128 * 8 RAM have
		1)128 memory locations
		2)7 address lines
		3)8 bits/location 
 		4)8 data lines
		5)size of each location = 1 byte = 8 bit
		6)capacity of the memory chip = 128 byte


**note-> for above chip we have total pins = 7(AD)+8(D)+2(VCC and GND)+3(E,WR and RD) = 20 pins
*if it is ROM then 7(AD)+8(D)+2(VCC and GND)+3(E,OE) = 19 pins
*2^10 bytes = 1KB
 2^20 bytes = 1MB.......so on

*classification of instructions based on different groups->

	group			instruction type	OPCODEs					
1)Data transfer Instruction		13		83
2)Arithmetic				14		62
3)Logical				15		43
4)Stack					9		15
5)Branch				8		36
6)I/O					2		2
7)Interrupt				5		5

TOTAL					66		246

-range of OPCODE is from 00H to FFH i.e. 256
-the instructions like LDA are stored in memory in the form of OPCODE like
LDA is stored as 3A
CMA = 2F
INR A = 3C etc.
-when mnemonic(like LDA) in an instruction(LAD F840H) is converted into hex (3A) is called opcode(operation codes)

*classification of instructions based on different sizes->
1) 1 byte long
1) 2 bytes long
1) 3 bytes long

*Data Transfer Instructions->
1)MVI r, d8->MoVe Immediate
-2 bytes = 16 bit instruction
-load a resister(GPR and A) with an 8 bit value

  opcode	MVI r,d8

   3E		MVI A,d8
   06		MVI B,d8
   0E		MVI C,d8
   16		MVI D,d8
   1E		MVI E,d8
   26		MVI H,d8
   2E		MVI L,d8
   
-3E is only correspond to 'MVI A' not d8

2)MOV r1,r2->
-r1(destination) and r2(source)
-lode resister r1 with the value in resister r2
-note that the data is copied in r1.there for it is present in r1 and r2 both after the execution
-1 byte instruction
-49 combination of instructions
ex., MOV A,B;

3)MOV r, M->
-load a resister with the 8 bit value in memory location 
-the location is accessed by using H,L pair of GPR for this we use resister-immediate addressing 
-1 byte instruction
-7 combination
ex., MOV A,M;

4) MOV M, r->
-load a memory location with the 8 bit value in  resister r
-all other function is same as 3rd instruction
-ex., MOV M,A;

5)LXI rp, d16->
-Load eXtended resister Immediate(extended resister = resister pairs)
-load a resister pair with an 16 bit value
-this instruction reduce no of instructions and hence instruction size
 without this instruction we need the following set of instructions 
	MOV H, F8H
	MOV L, 13H
-there for called as immediate addressing	
-3 byte instruction
-3 combinations
ex., LXI B,F813H

**note->in memory address are loaded in reverse order i.e. lower byte is loaded first

6)MVI M,d8->
-load a memory location with an 8 bit value
-resister-immediate addressing is used
-2 byte instruction

7)LDA a16->
-LoaD Accumulator  content from memory
we can do this using MOV A,M also but for this we need to involve the resister pair 
-by this instruction we don't need to do so
-3 byte
-ex., LDA F821H; 
-this also reduce the instruction size

8)STA a16->
-STore content in A in memory
-opposite to 'LDA a16' 

**note->7th and 8th instruction are only for A not for other GPRs

9)XEHG->
-eXCHanGe the content of H-L pair in D-E pair
-1byte
-reduce instruction and instruction size

10)LDAX rp->
-LoaD A from memory pointed by eXtended resister (resister pair)
-load the A with the data at memory location pointer by resister pair
-resister indirect addressing
-1 byte
-ex., LDAX B->
	1)memory address is stored in B-C pair
	2)data at that address is stored in A
-the instruction LDAX H; is not used cause we have the instruction MOV A,M; which do the same as LDAX H;
-2 combination LDAX B and LDAX D

11)STAX rp->
-STore A content in memory pointed by extended resister
-work exact;y opposite wat that of 10th 
-2 combination STAX B and STAX D

12)LHLD a16->
-Load H-L pair using Direct addressing from memory location
-Involves two consecutive memory location 
i.e. For LHLD F820H instruction following steps are done
11)data at address F820 is stored in L 
2)pointer point at F821 location 
3)data at F821 stored in H 
therefor two location are assessed in this instruction
-Absolute addressing
-3 bytes
-we don't have LBCD a16b or LDED a16 instructions

13)SHLD a16->
-Store data in H-L pair using Direct addressing in memory location
-this is exactly opposite to 12th instruction
 
*Resister codes in 8085->
			000-B
			001-C
			010-D
			011-E
			100-H
			101-L
			110-M
			111-A

*Formation of Opcodes->
1)	MOV A , B
	 |  |   |
        01 111 000 = 78 H

2)	MOV A , M
 	01 111 110 = 7E H

3)    |--MVI A        ,		EA H
      |	 00 111 110 = 3E H
      |__|______|


*Addressing Modes in 8085->
-difference ways of addressing the data is called addressing modes

1)Immediate Addressing mode: MVI A, 12h;
-MVI , LXI

2)Resister addressing mode: MOV A,B; (we are not specifying data instead we specify resister)

3)Absolute Addressing mode: LDA F820H; (we not specify data or resister innated we provide address)
-Also called as Direct Addressing Mode
-LDA , STA , LHLD , SHLD

4)Resister Indirect Addressing Mode: MOV A,M; (indirectly involve H-L pair)
-LDAX rp , STAX rp

5)Implied Addressing Mode: XCHG

*********
-in LXI H, 1234H-> 
1234H this data is directly stored in H-L pair and act as address of location the pointer is pointing to this location
-in LHLD 1234H->
pointer point to 1234H and then 1235H respectively an data at this locations is stored in H-L pair
-LDA F900H->load the data at F900H location in A
-STA F900H->store the data in A at location  F900H 
-MVI M,8DH->store data(8D) at the location stored in H-L pair(say 1234) 
*********

*Arithmetic Instruction->
-this instructions affect the Flag resister
1)ADD R->
-ADD content of R to A and result is stored in A itself
-1 byte
-8 combination with all GPRs,A and M

2)ADI d8->
-ADd Immediate to A
-Immediate addressing
-2 bytes

3)INR R->
-INcRement the content of R by 1
-All flags except CY flag are affected depending on the result
 cause this is not addition if we perform INR operation on FF data then it will simply reset to 00
-1 byte
-8 combination with all GPRs, A and M

4)ADC R->
-ADd with Carry the content of R in A and result is stored in A itself
-1 byte
-8 combinations
-ex., 				1
			4	5	5	6	H
			3	3	F	3	H
		       ___________________________	
			7	9	4	9	H
steps->	1)addition of lower 2 digits is done
	2)as carry is generated Cy flag set to 1		
	3)addition of higher 2 digit is done along with carry using 		instruction ADC .
	4)the result is stored in A
	4)no carry is generated therefor Cy flag sat to 0

5)ACI d8->
-Add with Carry Immediate to A
-immediate addressing
-2 byte
-same as 4th but 2nd data(operand) is given in instruction itself an s1st operand is i A  
-ex., ACI 12H
			1
		F	1	H 
		1	2	H
	       ___________	
		0	4	H

6)SUB R->
-same as ADD R but subtraction is carried on
-and generated carry is provided to Cy flag through an invertor

7)SUI d8->
-same as ADI d8 but subtraction is carried on

8)DCR R->
same as INR R but decrement by 1 is done

9)SBB R->
--SuBtract with Borrow the content of R in A and result is stored in A itself
-other properties are same as ADC R

10)SBI d8->
-same as ACI R only difference is subtraction is done here

11)INX rp->
-INcrement extended resister
-1 byte
- we can use INR C; instead of INX B;
-but this reduce the problem of reset FF to 00 after incrementing by 1 using INR C operation in memory location
-ex., by using INR C->
		F2FF--->FF00
By using INX B->	
		F2FF--->F300
hence with the help of INX B we can go to next address(location) in memory not by INR C

12)DCX rp->
-same as 11th instruction but decrement is done

13)DAD rp->
-16 bit addition is done
-Double ADd resister pair with H-L pair
-no flag except Cy flag is affected depending on result
-content in mention rp is added with content in H-L pair and result is stored in H-L pair
-3 combination
-1 byte


**note->
*BCD numbers-> 0 to 9 are valid 10 to 15 are unveiled
0000	0
0001	1
0010	2
0011	3
0100	4
0101	5
0110	6
0111	7
1000	8
1001	9
-------Invalid------
1010	10	       	
1011	11
1100	12
1101	13
1110	14
1111	15

to solve this we have to add 6 in Invalid no.

-ex., 1024->
in BCD   -> 	0001 0000 0010 0100
in binary->	0000 0100 0000 0000 

14)DAA->
-Decimal Adjust A
-action taken by instruction depend on the content of A ,AC and Cy flag
-if LS Hex digit <=9 & AC=0 the LS Hex digit wont be altered 
-if LS Hex digit >=9 or AC=1 DAA instruction adds 6 to the LS Hex digit
-if MS Hex digit <=9 & Cy=0 the LS Hex digit wont be altered 
-if MS Hex digit >=9 or Cy=1 DAA instruction adds 6 to the LS Hex digit

-ex.,1) 5	3	8	9
	3	6	0	0
	---------	---------	
	8	9	8	9  -----no action taken by DAA

2)	4	5	7	D
	3	8	0	6
	---------	---------
	7	D	8	3  -----6 to LS is added by DAA

*logical Instructions->

*AND logic->
-we know that	XY O/P
		00 0
		01 0
		10 0
		11 1
i.e. X AND 1 = X
     X AND 0 = 0	
-it reset bit of A
-in this operation Cy flag is always '0' and AC flag is always '1' remaining flag are affected result 

1)ANA R->
-ANd A with R
-1 byte
-8 combinations

2)ANI d8->
-ANd Immediate with A
-2 byte

*OR logic->
-we know that	XY O/P
		00 0
		01 1
		10 1
		11 1
i.e. X OR 1 = 1
     X OR 0 = X	
-it set bit of A
-in this operation Cy flag is always '0' and AC flag is always '0' remaining flag are affected result 	

3)ORA R->
-OR A with R
-1 byte
-8 combinations

4)ORI d8->
-OR Immediate with A
-2 byte

*Ex-OR logic->
-we know that	XY O/P
		00 0
		01 1
		10 1
		11 0
i.e. X OR 1 = complement of X
     X OR 0 = X	
-it compliment bit of A
-in this operation Cy flag is always '0' and AC flag is always '0' remaining flag are affected result 

5)XRA R->
- eXclusive OR A with R
-1 byte
-8 combinations

6)XRI d8->
-eXclusive OR Immediate with A
-2 byte

7)CMA->
-CoMplement the A
-no flag are affected
-ex., 12H->0001 0010
           1110 1101
-1 byte

8)CMC and STC->
-CMC->CoMplement the Carry flag
-1 byte
-give 0->1 and 1->0

-STC->SeT the Carry flag
-1 byte
-give 0->1 and 1->1

**note->
-for resetting the Cy flag 
1)set the carry flag
2)complement the carry flag

-for NAND->first apply instruction for AND logic and then CMA instruction
-for NOR->first apply instruction for OR logic and then CMA 

*Compare Operation->
-we do subtraction(by addition) of the operands
if result is 0 data is same
if result is +ve 1st operand bigger
if result is -ve 1st operand smaller
-the result is not stored in A instead it is store in a temporary resister

9)CMP R->
-CoMPare A with R
-flags are affected based on the Temporary Resister content
-1 byte
-8 combinations (Opcode)
-1)if Cy=0 and Z=0 then A>R
-2)if Cy=1 and Z=0 then A<R
-3)if Cy=0 and Z=1 then A=R
 
10)CPI d8->
-ComPare Immediate with A
-2 byte
-other step are same as 9th

11)RLC->
-Rotate A to Left(-->) and send a Copy to Cy flag
-1 byte
-it is used for 1)checking the value of the MSB
		2)Performing multiplication by 2(if MSB is 0 only)
-ex., 	24H=48H(2*24)
	00100100 -> 01001001

11)RAL->
-Rotate A to Left involving the Cy flag
-1 byte
-it is used for 1)checking the value of the MSB
		2)Performing multiplication by 2(if MSB is 0 only and Cy=0)
		3)Introducing a new bit as LSB
-ex.,	A=85H & Cy=0 --> A=0AH & Cy=1
	0 10000101 -->1 00001010

12)RRC->
-Rotate A to Right(<--) and send a Copy to Cy flag
-1 byte
-it is used for 1)checking the value of the LSB
		2)Performing division by 2(if LSB is 0 only)
-ex.,	48H=24H
	01001001 -> 00100100

13)RAR->
-Rotate A to right involving the Cy flag
-1 byte
-it is used for 1)checking the value of the LSB
		2)Performing multiplication by 2(if MSB is 0 only and Cy=0)
		3)Introducing a new bit as MSB


***********
Sim8085 Emulator web to test the program memory allocation
***********
*program->
data at 4400H = 02
LAD 4400H
RLC
RLC
STD 4410H
HLT
O/P-> data at 4410H = 08






